summary(aov.cu)
aov.ni = aov(Ni~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.ni)
aov.pb = aov(Pb~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.pb)
aov.zn = aov(Zn~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.zn)
library(RGeostats)
constant.define("asp",1) #environment variable for the scale ratio between axes
library(Rcpp)
library(RGeostats)
constant.define("asp",1) #environment variable for the scale ratio between axes
#Data set
jura_tot = read.csv("../jura/jura_pred.csv")
jura_tot$Landuse = as.factor(jura_tot$Landuse)
#Data set
jura_tot = read.csv("../jura/jura_pred.csv")
jura_tot$Landuse = as.factor(jura_tot$Landuse)
#Data set
jura_tot = read.csv("../jura/jura_pred.csv")
jura_tot$Landuse = as.factor(jura_tot$Landuse)
#Data set
jura_tot = read.csv("../../jura/jura_pred.csv")
#Prediction grid
grid = read.csv("../../jura/jura_grid.csv")
names(jura_tot)
names(grid)
jura_tot$Landuse = as.factor(jura_tot$Landuse)
jura_tot$Rock = as.factor(jura_tot$Rock)
grid$Landuse = as.factor(grid$Landuse)
grid$Rock = as.factor(grid$Rock)
jura_tot$Landuse = as.factor(jura_tot$Landuse)
jura_tot$Rock = as.factor(jura_tot$Rock)
grid$Landuse = as.factor(grid$Landuse)
grid$Rock = as.factor(grid$Rock)
levels(jura_tot$Landuse)
levels(grid$Landuse)
levels(jura_tot$Landuse)=c("Forest","Pasture","Meadow","Tillage")
levels(jura_tot$Rock)
levels(grid$Rock)
levels(jura_tot$Rock)=c("Argovian","Kimmeridgian","Sequanian","Portlandian","Quaternary")
set.seed(1234) #Set the seed of the random generators
ntot = nrow(jura_tot)
ntrain = 200
nval = ntot - ntrain
indtrain = sample(ntot,ntrain)
indval = setdiff(1:ntot,indtrain)
jura = jura_tot[indtrain,]
val_loc = jura_tot[indval,1:4]
#val contains the values to predict. For the project, these values will be on Kaggle
#(for other locations) and you won't know them
#You will have the locations and covariables at the unknown locations by the following command :
#val_loc = read.csv("jura/jura_val_loc.csv")
val = cbind(1:nval,jura_tot[indval,]$Co)
gridtemp = db.create(grid)
gridtemp = db.locate(gridtemp,c("Xloc","Yloc"),"x")
nx = c(length(unique(grid[,1])),length(unique(grid[,2])))
gridrg = db.grid.init(gridtemp,nodes=nx)
gridrg = migrate(gridtemp,gridrg,names=4:gridtemp$natt,radix="")
gridrg = db.rename(gridrg,2:3,c("Xloc","Yloc"))
gridrg = db.sel(gridrg,!is.na(gridrg[,"Landuse"])&!is.na(gridrg[,"Rock"]))
add.variable =function(var,grid,varname,gridtemp.=gridtemp)
{
tt=db.add(gridtemp.,var)
tt=db.rename(tt,tt$natt,varname)
grid = migrate(tt,grid,names=tt$natt,radix="")
grid
}
library(Rcpp)
library(RGeostats)
constant.define("asp",1) #environment variable for the scale ratio between axes
#Data set
jura_tot = read.csv("../../jura/jura_pred.csv")
#Prediction grid
grid = read.csv("../../jura/jura_grid.csv")
names(jura_tot)
names(grid)
jura_tot$Landuse = as.factor(jura_tot$Landuse)
jura_tot$Rock = as.factor(jura_tot$Rock)
grid$Landuse = as.factor(grid$Landuse)
grid$Rock = as.factor(grid$Rock)
levels(jura_tot$Landuse)
levels(grid$Landuse)
levels(jura_tot$Landuse)=c("Forest","Pasture","Meadow","Tillage")
levels(jura_tot$Rock)
levels(grid$Rock)
levels(jura_tot$Rock)=c("Argovian","Kimmeridgian","Sequanian","Portlandian","Quaternary")
set.seed(1234) #Set the seed of the random generators
ntot = nrow(jura_tot)
ntrain = 200
nval = ntot - ntrain
indtrain = sample(ntot,ntrain)
indval = setdiff(1:ntot,indtrain)
jura = jura_tot[indtrain,]
val_loc = jura_tot[indval,1:4]
#val contains the values to predict. For the project, these values will be on Kaggle
#(for other locations) and you won't know them
#You will have the locations and covariables at the unknown locations by the following command :
#val_loc = read.csv("jura/jura_val_loc.csv")
val = cbind(1:nval,jura_tot[indval,]$Co)
gridtemp = db.create(grid)
gridtemp = db.locate(gridtemp,c("Xloc","Yloc"),"x")
nx = c(length(unique(grid[,1])),length(unique(grid[,2])))
gridrg = db.grid.init(gridtemp,nodes=nx)
gridrg = migrate(gridtemp,gridrg,names=4:gridtemp$natt,radix="")
gridrg = db.rename(gridrg,2:3,c("Xloc","Yloc"))
gridrg = db.sel(gridrg,!is.na(gridrg[,"Landuse"])&!is.na(gridrg[,"Rock"]))
add.variable =function(var,grid,varname,gridtemp.=gridtemp)
{
tt=db.add(gridtemp.,var)
tt=db.rename(tt,tt$natt,varname)
grid = migrate(tt,grid,names=tt$natt,radix="")
grid
}
mean((val[,2]-mean(val[,2]))^2)
#Fit the anova model
aov.co = aov(Co~Landuse+Rock,data=jura)
summary(aov.co)
#Prediction on the validation locations
res.aov.val=predict(aov.co,val_loc)
##
#Compute score
mean((res.aov.val-val[,2])^2)
#Prediction on the grid
res.aov=predict(aov.co,grid)
##
#Add to the RGeostats db and display
gridrg = add.variable(res.aov,gridrg,"aov.predict")
plot(gridrg,pos.legend=1)
#Fit the linear model
trend = lm(Co~Xloc+Yloc+Xloc*Yloc+I(Xloc^2)+I(Yloc^2),data=jura)
summary(trend)
#Prediction on the validation locations
res.trend.val=predict(trend,val_loc)
##
#Compute score
mean((res.trend.val-val[,2])^2)
##
#Prediction on the grid
res.trend=predict(trend,grid)
#Add to the RGeostats db and display
gridrg = add.variable(res.trend,gridrg,"trend.predict")
plot(gridrg,pos.legend=1)
ns =  3 #number of samples to consider for the prediction
datrg = db.create(jura)
datrg = db.locate(datrg,2:3,"x")
datrg = db.locate(datrg,7,"z")
m = model.create(1)
neigh=neigh.create(radius=100,nmini=ns,nmaxi=ns)
###
valrg=db.create(val_loc)
valrg=db.locate(valrg,2:3,"x")
res.val = kriging(datrg,valrg,m,neigh)
mean((res.val[,6]-val[,2])^2,na.rm=T)
###
res = kriging(datrg,gridrg,m,neigh)
plot(res)
degree = 4
datrg = db.create(jura)
datrg = db.locate(datrg,2:3,"x")
datrg = db.locate(datrg,7,"z")
###
valrg=db.create(val_loc)
valrg=db.locate(valrg,2:3,"x")
res.val = invdist(datrg,valrg,exponent = degree)
mean((res.val[,6]-val[,2])^2)
res = invdist(datrg,gridrg)
plot(res)
library(RGeostats)
jurarg = db.create(jura)
jurarg = db.locate(jurarg,c("Xloc","Yloc"),"x")
jurarg = db.locate(jurarg,"Co","z")
v = vario.calc(jurarg,nlag=10)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=100)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=1000)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=10)
draw.vario(v,npairpt = T,npairdw = T)
v = vario.calc(jurarg,nlag=50)
draw.vario(v,npairpt = T,npairdw = T)
v = vario.calc(jurarg,nlag=100)
draw.vario(v,npairpt = T,npairdw = T)
plot(vmap.calc(jurarg))
vdir = vario.calc(jurarg,nlag=10,dir=c(0,-45,45))
plot(vdir)
maniso = model.auto(vdir,struct=c(1,2,3,4))
maniso = model.auto(vdir,struct=c(1,2,3,4))
model.auto(v,struct=c(1,8))
model.auto(v,struct=c(1,4))
model.auto(v,struct=c(1,4))
model.auto(v,struct=c(1,2))
model.auto(v,struct=c(1,2,3,8))
model.auto(vdir,struct=c(1,8))
model.auto(vdir,struct=c(1,4))
model.auto(vdir,struct=c(1,2))
model.auto(vdir,struct=c(1,2,3,8))
vmap.auto(vmap.calc(jurarg),struct=c(1,8))
vmap.auto(vmap.calc(jurarg),struct=c(1,4))
vmap.auto(vmap.calc(jurarg),struct=c(1,2))
vmap.auto(vmap.calc(jurarg),struct=c(1,2,3,8))
jurarg = db.create(jura)
jurarg = db.locate(jurarg,c("Xloc","Yloc"),"x")
jurarg = db.locate(jurarg,"Co","z")
v = vario.calc(jurarg,nlag=500)
m = model.auto(v,struct = c(1,8))
grid = read.csv("./data_set/jura/jura_grid.csv")
jurarg = db.create(jura)
jurarg = db.locate(jurarg,c("Xloc","Yloc"),"x")
jurarg = db.locate(jurarg,"Co","z")
v = vario.calc(jurarg,nlag=500)
m = model.auto(v,struct = c(1,8))
grid = read.csv("../../jura/jura_grid.csv")
gridtemp = db.create(grid)
gridtemp = db.locate(gridtemp,c("Xloc","Yloc"),"x")
nx = c(length(unique(grid[,1])),length(unique(grid[,2])))
gridrg = db.grid.init(gridtemp,nodes=nx)
gridrg = migrate(gridtemp,gridrg,names=4:gridtemp$natt,radix="")
gridrg = db.rename(gridrg,2:3,c("Xloc","Yloc"))
gridrg = db.sel(gridrg,!is.na(gridrg[,"Landuse"])&!is.na(gridrg[,"Rock"]))
neigh = neigh.create(type = 0)
res=kriging(jurarg,gridrg,m,neigh)
plot(res)
neigh = neigh.create(nmini=10,nmaxi=30,radius=1)
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)
neigh = neigh.create(nmini=10,nmaxi=30,radius=3,flag.sector = T,nsect=12,nsmax=30)
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)
v = vario.calc(jurarg,nlag=300)
m = model.auto(v,struct = c(1,13))
neigh = neigh.create(nmini=10,nmaxi=30,radius=2.5)
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)
v = vario.calc(jurarg,nlag=300)
m = model.auto(v,struct = c(1,14))
neigh = neigh.create(nmini=10,nmaxi=30,radius=2.5)
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)
v = vario.calc(jurarg,nlag=300)
m = model.auto(v,struct = c(1,14))
neigh = neigh.create(type=0)
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)
indiccut = limits.create(mini=c(1,2,3),maxi=c(2,3,4))
jurarg_KU=db.indicator(jurarg,indiccut,name="Rock")
jurarg_KU = db.locate(jurarg_KU,"Indicator*","f")
jurarg_KU = db.locate(jurarg_KU,"Co","z")
gridrg_KU=db.indicator(gridrg,indiccut,name="Rock")
gridrg_KU = db.locate(gridrg_KU,"Indicator*","f")
gridrg_KU = db.locate(gridrg_KU,"Co","z")
val_locrg_KU=db.indicator(val_locrg,indiccut,name="Rock")
val_locrg_KU = db.locate(val_locrg_KU,"Indicator*","f")
val_locrg_KU = db.locate(val_locrg_KU,"Co","z")
drift = c("1","f1","f2","f3")
vres = vario.calc(jurarg_KU,nlag=10,uc=drift)
plot(v)
plot(vres,add=T,col=2)
mres=model.auto(vres,struct=c(1,2))
neigh=neigh.create(type=0)
res_gridKU=kriging(jurarg_KU,gridrg_KU,mres,neigh,uc=drift)
plot(res_gridKU)
res_valKU=kriging(jurarg_KU,val_locrg_KU,mres,neigh,uc=drift)
mean((res_valKU[,"Kriging*estim"]-val[,2])^2)
indiccut = limits.create(mini=c(1,2,3),maxi=c(2,3,4))
jurarg_KU=db.indicator(jurarg,indiccut,name="Landuse")
jurarg_KU = db.locate(jurarg_KU,"Indicator*","f")
jurarg_KU = db.locate(jurarg_KU,"Co","z")
gridrg_KU=db.indicator(gridrg,indiccut,name="Landuse")
gridrg_KU = db.locate(gridrg_KU,"Indicator*","f")
gridrg_KU = db.locate(gridrg_KU,"Co","z")
val_locrg_KU=db.indicator(val_locrg,indiccut,name="Landuse")
val_locrg_KU = db.locate(val_locrg_KU,"Indicator*","f")
val_locrg_KU = db.locate(val_locrg_KU,"Co","z")
drift = c("1","f1","f2","f3")
vres = vario.calc(jurarg_KU,nlag=10,uc=drift)
plot(v)
plot(vres,add=T,col=2)
mres=model.auto(vres,struct=c(1,2))
drift = c("1","f1","f2","f3")
vres = vario.calc(jurarg_KU,nlag=100,uc=drift)
mres=model.auto(vres,struct=c(1,8))
neigh = neigh.create(type=0)
res_valKU=kriging(jurarg_KU,val_locrg_KU,mres,neigh,uc=drift)
mean((res_valKU[,"Kriging*estim"]-val[,2])^2)
mres=model.auto(vres,struct=c(1,2))
res_valKU=kriging(jurarg_KU,val_locrg_KU,mres,neigh,uc=drift)
mean((res_valKU[,"Kriging*estim"]-val[,2])^2)
mres=model.auto(vres,struct=c(1,14))
res_valKU=kriging(jurarg_KU,val_locrg_KU,mres,neigh,uc=drift)
mean((res_valKU[,"Kriging*estim"]-val[,2])^2)
indiccut = limits.create(mini=c(1,2,3),maxi=c(2,3,4))
jurarg_KU=db.indicator(jurarg,indiccut,name="Landuse")
jurarg_KU = db.locate(jurarg_KU,"Indicator*","f")
jurarg_KU = db.locate(jurarg_KU,"Co","z")
gridrg_KU=db.indicator(gridrg,indiccut,name="Landuse")
gridrg_KU = db.locate(gridrg_KU,"Indicator*","f")
gridrg_KU = db.locate(gridrg_KU,"Co","z")
val_locrg_KU=db.indicator(val_locrg,indiccut,name="Landuse")
val_locrg_KU = db.locate(val_locrg_KU,"Indicator*","f")
val_locrg_KU = db.locate(val_locrg_KU,"Co","z")
drift = c("1","f1","f2","f3")
vres = vario.calc(jurarg_KU,nlag=10,uc=drift)
plot(v)
plot(vres,add=T,col=2)
mres=model.auto(vres,struct=c(1,2))
neigh=neigh.create(type=0)
res_gridKU=kriging(jurarg_KU,gridrg_KU,mres,neigh,uc=drift)
plot(res_gridKU)
drift = c("1","f1","f2","f3")
vres = vario.calc(jurarg_KU,nlag=100,uc=drift)
mres=model.auto(vres,struct=c(1,14))
radvec=c(2.2,2.6)
neigh = neigh.create(type=2,nmini=5,nmaxi=5,radius=radvec,flag.sector = T,flag.aniso=T,nsect = 52,nsmax = 100)
res_valKU=kriging(jurarg_KU,val_locrg_KU,mres,neigh,uc=drift)
mean((res_valKU[,"Kriging*estim"]-val[,2])^2)
jurarg = db.locate(jurarg,c("Co","Zn","Cu"),"z")
vdir = vario.calc(jurarg,nlag=10,dir=c(-10,35,80,125))
plot(vdir)
m = model.auto(vdir,struct=c(1,8))
grid = read.csv("./data_set/jura/jura_grid.csv")
grid = read.csv("../../jura/jura_grid.csv")
gridtemp = db.create(grid)
gridtemp = db.locate(gridtemp,c("Xloc","Yloc"),"x")
nx = c(length(unique(grid[,1])),length(unique(grid[,2])))
gridrg = db.grid.init(gridtemp,nodes=nx)
gridrg = migrate(gridtemp,gridrg,names=4:gridtemp$natt,radix="")
gridrg = db.rename(gridrg,2:3,c("Xloc","Yloc"))
gridrg = db.sel(gridrg,!is.na(gridrg[,"Landuse"])&!is.na(gridrg[,"Rock"]))
neigh = neigh.create(type = 0)
res = kriging(jurarg,gridrg,m,neigh)
plot(res,sub="Cokriging of Co")
val_locrg = db.create(val_loc)
val_locrg = db.locate(val_locrg,c("Xloc","Yloc"),"x")
res_val = kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging.Co.estim"]-val[,2])^2)  ## MSE for Cokriging
neigh = neigh.create(type = 0)
res = kriging(jurarg,gridrg,m,neigh)
plot(res,sub="Cokriging of Co")
v=vmap.calc(jurarg)
std_co=sqrt(v$items[["VMAP.Co"]])
std_zn_co=sqrt(v$items[["VMAP.Zn.Co"]])
std_zn=sqrt(v$items[["VMAP.Zn"]])
std_cu_co=sqrt(v$items[["VMAP.Cu.Co"]])
std_cu_zn=sqrt(v$items[["VMAP.Cu.Zn"]])
std_cu=sqrt(v$items[["VMAP.Cu"]])
v1=db.add(v,std_co,std_zn_co,std_zn,std_cu_co,std_cu_zn,std_cu)
par(mfrow=c(2,3))
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Co")
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Zn.Co")
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Zn")
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Cu.Co")
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Cu.Zn")
plot(v1,pos.x = 1,pos.y = 2,name="VMAP.Cu")
plot(v1,pos.x = 1,pos.y = 2,name="std_co")
plot(v1,pos.x = 1,pos.y = 2,name="std_zn_co")
plot(v1,pos.x = 1,pos.y = 2,name="std_zn")
plot(v1,pos.x = 1,pos.y = 2,name="std_cu_co")
plot(v1,pos.x = 1,pos.y = 2,name="std_cu_zn")
plot(v1,pos.x = 1,pos.y = 2,name="std_cu")
jurarg <- db.locate(jurarg, c("Zn","Cu"))# Remove Zn,Cu
# Variogram
v = vario.calc(jurarg,nlag=12)
m = model.auto(v,c(1,3,3))
# Ordinary Kriging
neigh = neigh.create(type = 0)
res=kriging(jurarg,gridrg,m,neigh)
plot(res,sub="Kriging of Co")
# Ordinary Kriging on val
res_val=kriging(jurarg,val_locrg,m,neigh)
mean((res_val[,"Kriging*estim"]-val[,2])^2)  ## MSE for Ordinary kriging
res_simu = simtub(jurarg_KU,gridrg_KU,mres,neigh,nbsimu=100,nbtuba=1000)
res_simu[,"Simu.Co.S*"] = res_simu[,"Simu.Co.S*"]>12
res_simu[,"Simu.Co.S1"] <- rowMeans(res_simu[,"Simu.Co.S*"])
plot(res_simu,name="Simu.Co.S1",pos.legend=1)
model.auto(vdir,struct=as.vector(c(1,2,3,8)))
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls()) #Clean the working directory
#Data set
jura = read.csv("../../jura/jura_pred.csv")
class(jura)
str(jura) #e.g.
names(jura)
min(jura$Xloc);min(jura$Yloc)
apply(jura[,1:2],2,min)
range(jura$Xloc)
max(jura$Xloc);max(jura$Yloc)
apply(jura[,1:2],2,max)
range(jura$Yloc)
summary(jura[,5:11])
apply(jura[,5:11],2,sd)
mean(jura[jura$Landuse==1,6],na.rm=T)
mean(jura[jura$Landuse==2,6],na.rm=T)
mean(jura[jura$Landuse==3,6],na.rm=T)
mean(jura[jura$Landuse==4,6],na.rm=T)
plot(jura)
plot(jura[,1:2])
plot(jura[,1:2])
points(jura[jura$Landuse==2,1:2],col='red')
par(mfrow=c(2,4)) # on a grid of 2x4 plots
hist(jura$Cd)
hist(jura$Co)
hist(jura$Cr)
hist(jura$Cu)
hist(jura$Ni)
hist(jura$Pb)
hist(jura$Zn)
par(mfrow=c(2,4))
plot(jura$Landuse,jura$Cd)
plot(jura$Landuse,jura$Co)
plot(jura$Landuse,jura$Cr)
plot(jura$Landuse,jura$Cu)
plot(jura$Landuse,jura$Ni)
plot(jura$Landuse,jura$Pb)
plot(jura$Landuse,jura$Zn)
par(mfrow=c(2,4))
plot(jura$Rock,jura$Cd)
plot(jura$Rock,jura$Co)
plot(jura$Rock,jura$Cr)
plot(jura$Rock,jura$Cu)
plot(jura$Rock,jura$Ni)
plot(jura$Rock,jura$Pb)
plot(jura$Rock,jura$Zn)
jura$Landuse = as.factor(jura$Landuse)
jura$Rock = as.factor(jura$Rock)
aov.co = aov(Co~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.co)
aov.cd = aov(Cd~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.cd)
aov.cr = aov(Cr~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.cr)
aov.cu = aov(Cu~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.cu)
aov.ni = aov(Ni~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.ni)
aov.pb = aov(Pb~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.pb)
aov.zn = aov(Zn~Landuse+Rock+Landuse*Rock,data=jura)
summary(aov.zn)
library(RGeostats)
jurarg = db.create(jura)
jurarg = db.locate(jurarg,c("Xloc","Yloc"),"x")
jurarg = db.locate(jurarg,"Co","z")
v = vario.calc(jurarg,nlag=10)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=100)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=1000)
m = model.auto(v,struct = c(1,8))
v = vario.calc(jurarg,nlag=10)
draw.vario(v,npairpt = T,npairdw = T)
v = vario.calc(jurarg,nlag=50)
draw.vario(v,npairpt = T,npairdw = T)
v = vario.calc(jurarg,nlag=100)
draw.vario(v,npairpt = T,npairdw = T)
plot(vmap.calc(jurarg))
vdir = vario.calc(jurarg,nlag=10,dir=c(0,-45,45))
plot(vdir)
maniso = model.auto(vdir,struct=c(1,2,3,4))
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls()) #Clean the working directory
#Data set
jura = read.csv("../../jura/jura_pred.csv")
class(jura)
str(jura) #e.g.
names(jura)
min(jura$Xloc);min(jura$Yloc)
apply(jura[,1:2],2,min)
range(jura$Xloc)
max(jura$Xloc);max(jura$Yloc)
apply(jura[,1:2],2,max)
range(jura$Yloc)
summary(jura[,5:11])
apply(jura[,5:11],2,sd)
mean(jura[jura$Landuse==1,6],na.rm=T)
mean(jura[jura$Landuse==2,6],na.rm=T)
mean(jura[jura$Landuse==3,6],na.rm=T)
mean(jura[jura$Landuse==4,6],na.rm=T)
plot(jura)
install.packages("ggplot2")
library("ggplot2")
ggplot(jura, aes(x = Landuse, y = Co, fill = Landuse)) +
geom_boxplot() +
geom_jitter(shape = 15,
color = "steelblue",
position = position_jitter(0.21)) +
theme_classic()
ggplot(jura, aes(x = Rock, y = Co, fill = Rock)) +
geom_boxplot() +
geom_jitter(shape = 15,
color = "steelblue",
position = position_jitter(0.21)) +
theme_classic()
#Fit the anova model
aov.co = aov(Co~Landuse+Rock,data=jura)
summary(aov.co)
install.packages("randomForest")
install.packages("geoR")
mean(jura$Co)
var(jura$Co)
ml =likfit(jura.geoR, ini = c(10,0.5), nug = 0.5,fix.psiA = F, psiA = pi/3,fix.psiR = F, psiR=1, trend = trend.spatial(trend = ~Indicator.Rock.1 + Indicator.Rock.2 + Indicator.Rock.3,jura.geoR))
